\documentclass[11pt]{article}
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{23.5cm}
\setlength{\textwidth}{17.0cm}
\setlength{\oddsidemargin}{.025in}
\setlength{\evensidemargin}{.025in}
\setlength{\textwidth}{6.25in}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{float}
\usepackage{Sweave}

\newcommand{\mqm}{\emph{MQM}}
\newcommand{\MQM}{\mqm}
\newcommand{\qtl}{QTL}
\newcommand{\QTL}{\qtl}
\newcommand{\lod}{LOD}
\newcommand{\cM}{cM}
\newcommand{\rqtl}{\emph{R/qtl}}
\newcommand{\cim}{\emph{CIM}}
\newcommand{\At}{\emph{Arabidopsis thaliana}}
\newcommand{\FIXME}{({\bf FIXME!})}
\newcommand{\CHECK}{({\bf CHECK!})}
\newcommand{\NOTE}{({\tt NOTE: })}
\newcommand{\hyperintro}{\qtl\ profiles of the hyper dataset with the trait bp (blood
pressure) in an experiment with 250 mice using \mqm}
\newcommand{\hyperintrocolors}{ \qtl\ profiles of the hyper dataset with the trait bp (blood pressure) in an experiment with 250 mice comparing \mqm\ (black) and
single \qtl\ mapping with $scanone$ (green)}

\title { Chapter 12 - Multiple QTL Model (MQM) Analysis }
\author { Danny Arends, Pjotr Prins, Karl Broman and Ritsert Jansen }
\begin {document}
\maketitle
\clearpage

\section{Introduction}

\mqm\ allows the mapping of \qtl\ using an automated model selection method, as
described by R.C. Jansen\cite{jansen94}. \mqm\ is part of
the free \rqtl\ R package\cite{rqtlbook}\cite{broman09}\cite{broman03} and consists of a three step procedure:
(1) data augmentation, (2) automatic backward model elimination using genetic
markers as cofactors and (3) QTL (interval) mapping using the most
'informative' model. The method internally controls false discovery rates (FDR) and
lets users test different QTL models by elimation of non-significant
cofactors\footnote{We assume the reader knows how to load his data into R using
the R/qtl $read.cross$ function, see also the R/qtl tutorials\cite{broman09} and book\cite{rqtlbook}}.

\input{mqm/limitations.txt}

Still, \mqm\ is a valuable addition to the \qtl\ mapper's toolbox. It is able
to deal with interference of \qtl, handles missing data and allows more precise
detection than other methods. This tutorial will show how to use \mqm\ for
\qtl\ mapping. Also R/qtl's \mqm\ is faster than other implementations and
scales on multi-CPU systems and computer clusters.

\section{A quick overview}

These are the typical steps in an \mqm\ \qtl\ analysis
\begin{itemize}
\item Load an experiment using R/qtl data types
\item Select trait under consideration
\item Fill in missing data using either the $fill.geno$ or $mqmaugmentdata$ routine
\item Call $mqmscan$ to execute a genome scan
\item Call $mqmscan$ with $n.run$ to get an estimate of "significant" lod scores
\item Select cofactors at certain marker locations
\item Analysis with cofactors
\item Finally, a bootstrap analysis with $cofactors$ to get estimates of significance
\end{itemize}

Using (restricted) maximum likelihood  the algorithm employs a backward
selection strategy to identify \qtl\ hotspot. The algorithm passes through the
following stages:

\begin{itemize}
\item (Re)-estimation of the genetic map based on the genotypes provided
\item Calculation of relative marker positions and detection of linkage groups
\item (Re)-estimation of recombination frequencies
\item Likelihood estimations of the full model using all markers
\item Backward elimination of cofactors, followed by a
      genome scan for \qtl\ using the model (see section \label{QTL modelling})
\item If there are no $cofactors$, perform a
      genome scan testing each genetic location independantly
\end{itemize}

The interval map created during the genome scan and the \qtl\ model are
returned as an (\mqm\ extended) R/qtl $scanone$ object. Several special
plotting routines are available for \mqm\ results.

\section{Data augmentation}
\label{augmentation}

Most real world datasets are incomplete. That is, genotype information is
missing, or can have multiple plausible values. \mqm\ automatically expands the
dataset by adding all potential variants and attaches a likelihood.  For
example, information is missing (unknown) at a marker location for one
individual. Based on the values of the neighbouring markers, and the
(estimated) recombination rate, a probability is attached.  With \mqm\ all
likely options are considered.  When genotypes A and B are possible at the
location two 'individuals' are created in the augmentation step, one with
genotype A, and one with genotype B. A probability is attached to either
variant. The combined probabilities of all markers tells us whether a
combination of variants is likely, or not.

To see an example of missing data with an F2 intercross, we can
visualize the genotypes of the individuals using $plot.geno$ In figure
\ref{missing data} there are 2\% missing values in white. The other
colors are genotypes at a certain position, for a certain
individual. Simulate an F2 dataset with 2\% missing markers as
follows:

<<>>=
library(qtl)
data(map10)
mycross <- sim.cross(map10, type="f2", n.ind=100, missing.prob=0.02)
@
\begin{figure}[ht]
<<fig=TRUE>>=
geno.image(mycross)
@
\caption{Simulate an F2 cross with 2\% missing data starting from the
map10 F2 intercross. The figure displays genotypes of 100 individuals 
with around 2\% missing data (white) for the map10 F2 intercross}
\label{missing data}
\end{figure}

Before we can go to the next step (\qtl\ genome scan), the data has to 
be completed (i.e. no more missing data).
There are two possibilities: either use the imputation function
$fill.geno$ or use the \mqm\ data augmentation routine $mqmaugment$.
With $fill.geno$ a 'most likely' genotype is filled in
using multiple imputations, estimating the missing marker genotypes.
In contrast, \emph{augmentation} introduces all variants. At this stage
$mqmaugment$ is specific to \mqm\footnote{Note that after
augmentation the resulting cross object is no longer suitable for the
use with $scan.one$ or \cim, because of the additional information
stored}. 

Here, we use \mqm's augmentation. The function $mqmaugment$ can fill in
missing genotypes for us. For each missing marker it fills in all possible
marker locations with all genotypes and calculates the probability. When the
probability is more likely than the $minprob$ parameter the \emph{augmented}
individual is stored in the new $crossobject$, ready for QTL mapping.

The important parameters are: $cross, pheno.col, maxaugind, minprob$ and
$verbose$ (see also the $mqmaugment$ help page in R). $maxaugind$ sets the
maximum number of \emph{augmented} genotypes per individual in a dataset. The
default of 60 is usually good enough (20 missing F2 markers or 30 missing BC
markers per individual). However higher numbers are needed when there are more
missing markers. Each individual is augmented with a probability of, at least,
$minprob$ - in other words, only augment genotypes that of individuals that are
above a probability of occurring (and drop the less likely cases). Note that
setting this value too low may result in dropping individuals entirely as
$maxaugind$ is quickly reached\footnote{The current version drops individuals
that go beyond $maxaugind$. This is undesired behaviour and will be fixed in an
upcoming release. A value $minprob=1$ may prevent the dropping of individuals,
making augmentation behave like $fill.geno$'s imputation method}. Use the verbose
option to get more feedback on the augmentation routine and check how many
individuals are dropped.

<<>>=
# displays warning because MQM ignores the X chromosome in an F2
augmentedcross <- mqmaugment(mycross, minprob=1)
@
\begin{figure}[ht]
<<fig=TRUE>>=
plot.geno(augmentedcross)
@
\caption{$plot.geno$ displays the genotypes of 100 filled individuals
($mqmaugment$ with $minprob=1$ means only the 'most likely' individual is
used and
no real expansion of the dataset takes place, similar to $fill.geno$)}
\end{figure}

With a lower $minprob$, less likely genotypes are also considered, and the
resulting \emph{augmented} dataset will be larger. The (weighted) augmented
individuals with all possible genotypes theoretically leads to more accurate
mapping when dealing with missing values \cite{jansen93}.  \footnote{Note that
the augmented dataset can only be used with \mqm\ functions.  \mqm\ functions
recognise expanded individuals as single entities.  Other R/qtl functions, like
$scanone$, assume the augmented individuals are \emph{real} individuals}

\begin{figure}[ht]
<<fig=TRUE>>=
augmentedcross <- mqmaugment(mycross, minprob=0.1)
plot.geno(augmentedcross)
@
\caption{$plot.geno$ displays the \emph{augmented} genotypes of 100 individuals. There are a total of 340 'expanded' individuals in this plot, because \mqm\ 
fills in missing markers with all likely genotypes (an average expansion of 3.4 per
individual)}
\end{figure}

\clearpage

\section{QTL modelling and mapping with MQM}

\label{QTL modelling}

The hyper tension \emph{hyper} dataset is a backcrossed (BC) offspring of mice with two
traits in the dataset: bloodpressure (bp) and sex. Here we show an example of
running both $scanone$ single marker \qtl\ analysis and $mqmscan$ multiple
\QTL\ model mapping, to map blood pressure \qtl.

% \texttt{qtl.mqm} help page into a \LaTeX{} document

<<>>=
# calculate scanone and mqm after filling missing data
data(hyper)
colors <- c("Black","Green")
lines <- c(2,1)
hyperaug <- mqmaugment(hyper, minprob=1)
result_scanone <- scanone(hyperaug)
result_no_cofactors <- mqm(hyperaug)
@

After loading $data(hyper)$ we create a dataset without missing genotypes using
the $mqmaugment$ routine discussed in section \ref{augmentation}.  Next we
scan for \qtl\ using both $scanone$ and $mqm$ routines (using default
parameters). Figure \ref{NoCofs} displays there is virtually no difference
in outcome.

\begin{figure}[p]
<<fig=TRUE>>=
# plot scanone/mqm comparison
plot(result_no_cofactors, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors. Both routines
are virtually equal when used without \emph{augmentation} and no extra parameters}
\label{NoCofs}
\end{figure}

Note that $mqm$ produces pseudo markers by default (unlike $scanone$). A pseudo-
marker has a name like c7.loc25 - i.e. the 25 \cM\ pseudo marker on chromosome 7. This is
because MQM uses interval mapping internally. The chromosomes are divided into
an equally spaced sections. Thus each chromosome is divided into fictional
markers spaced equally $stepsize$ \cM\ apart. A LOD score for underlying QTLs
is calculated at these fictional pseudo markers. A small $stepsize$ allows for
smoother profiles compared with pure marker based mapping approaches. The real
markers are listed between the pseudo markers. You can remove the pseudo markers
by using the function $mqmextractmarkers(res)$.

For (automatic) model selection in \mqm\ we first need to supply the
algorithm with an initial model.  This initial model can be produced in two
ways: by (1) building a model by hand (forward stepwise), or (2) by unsupervised
backward elimination on a large number of markers.  

First we will build the initial model by hand using a forward stepwise
approach.  A model consists of a set of markers we want to account for, like we
would account for sex as an external variable influencing our results. 
Start building the initial model by adding cofactors at markers with high LOD
scores. figure \ref{NoCofs} displayed a large QTL peek on chromosome 4 at 30 \cM,
so let us account for that by setting a cofactor at the marker nearest to the
peek on chromosome 4 and perform a new $mqm$
scan (result in figures \ref{Cofactor4} and \ref{Cofactor4b}):

<<>>=
#Summary results shows the highest lodscores per chromosome
summary(result_no_cofactors)
#find.marker extracts the marker nearest to chr4 at 30cM
find.marker(hyperaug,chr=4,pos=30)
#which.marker translates the name into a cofactor number
toset <- which.marker(hyperaug,"D4Mit164")
cofactorlist <- mqmcofactors(hyperaug,toset)
#scan again
result_1 <- mqm(hyperaug, cofactorlist)
@

\begin{figure}[ht]
<<fig=TRUE>>=
# plot after adding first cofactor
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result_1))
plot(result_1)
@
\caption{\hyperintro. A cofactor is added at chromosome 4 (D4Mit164) and kept in the
model. The LOD score (evidence) for a second QTL on chromosome 1 increases (see also
figure \ref{Cofactor4b})
} 
\label{Cofactor4}
\end{figure}

Figures \ref{Cofactor4} and \ref{Cofactor4b} show the effect of setting a single marker as a
cofactor related to the \qtl\ on chromosome 4, followed by an \mqm\ scan.  The
marker is not dropped and it passes initial thresholding to account for
the $cofactor.significance$ level. LOD scores are expected to change (slightly)
genome wide because of variation already explained by the \qtl\ on
chromosome 4. This can be shown by plotting these new
results against the \mqm\ \qtl\ mapping without cofactors (figure \ref{Cofactor4b}).

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result_1, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactor at chromosome 4 (D4Mit164) accounting for variation explained at that
location}
\label{Cofactor4b}
\end{figure}

Figure \ref{Cofactor4b} clearly shows the second peek on chromosome 1 at 70
\cM\ increases, so we add that to the model and check if the model with both
cofactors changes the \qtl. Again, combining $which.marker$ with $find.marker$,
adds the new cofactornumber $c$ with the cofactor already in $toset$ (see figure 
\ref{twowaycomparison}): 

<<>>=
# add another cofactor
# summary(result_1)
toset <- c(toset,which.marker(hyperaug,find.marker(hyperaug,1,70)))
cofactorlist <- mqmcofactors(hyperaug,toset)
result_2 <- mqm(hyperaug, cofactorlist)
@

\begin{figure}[ht]
<<fig=TRUE>>=
# plot after adding second cofactor
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result_2))
plot(result_2, result_1, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactors at chromosomes 1 and 4 there appears only a small difference in the likelihood 
scores for each chromosome. The LOD scores do not appear to improve much after adding 
the second cofactor on chromosome 4. But\ldots (see figure \ref{threewaycomparison}) }
\label{twowaycomparison}
\end{figure}


\begin{figure}[ht]
<<fig=TRUE>>=
# plot closeup of threeway comparison
plot(result_no_cofactors, result_1, result_2,chr=c(1,11,15),col=c("black","red","blue"),lwd=c(3,2,1))
@
\caption{Three way comparison of the last scans. We see here a closeup of chromosome 1
scanned using \mqm\ with 3 different cofactor settings: no cofactors (black), 
a single cofactor on chromosome 4 (Red) and cofactors on chromosome 1 and 4.(Blue) 
The LOD scores on chromosome 1 increase with more cofactors, while the peaks on
the chromosome 11 and 15 decrease}
\label{threewaycomparison}
\end{figure}

When using the functions $mqmcofactors$ and $mqmsetcofactors$, the
number of cofactors the user is trying to set is compared against the number of
individuals inside the cross object. If there is any danger of overfitting the
model the function will display an error and will not return a cofactorlist.
Also the residual degrees of freedom left are checked to make sure also the
user created cofactor lists do not overfit the modeling routine.

\mqm\ checks that no markers are included that are less significant than the
$cofactor.significance$ level specified by the user. The marker on chromosome 1
is informative enough to be included into the model. Thus creating a new
initial model consisting of cofactors on chromosome 4 and 1. This (forward)
selection of cofactors can continue untill there are no more informative
markers that can be included. Practically this means one keeps on adding
cofactors 
until the last added cofactor gets dropped from the model.

Manually determining which marker to set a cofactor can be very time consuming
in the case of many QTLs underlying a trait. Fortunately \mqm\ provides
unsupervised backward elimination on a large number of markers by setting
cofactors at every other marker. Iteratively the algorithm analyses all the
markers and drops the least informative from the model. This step is repeated
until a limited number of significant cofactors is left.

After backward elimination \mqm\ will scan each chromosome using the model that
includes the retained cofactors. Here we set a cofactor at every fifth
marker using $mqmsetcofactors$, and assess which chromosomes may be implicated in high bloodpressure (results in figures \ref{Backward1} and \ref{Backward2}):

<<>>=
# automatic cofactor selection through backward elimination
cofactorlist <- mqmsetcofactors(hyperaug,5)
result <- mqm(hyperaug, cofactorlist, plot=T)
@
\begin{figure}[ht]
<<fig=TRUE>>=
# plot result of cofactor backward elimination
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result))
plot(result)
@
\caption{\hyperintro, after introducing cofactors at every fifth marker and
backward elimination}
\label{Backward1}
\end{figure}
<<>>=
mqmgetmodel(result)
@

$mqmgetmodel$ function returns the final model from the resulting $scanone$
object.  This model can be used with the $scantwo$ routine from R/qtl. $mqmgetmodel$ 
can only be used after backward elimination as it needs a list of
cofactors. The resulting model can also be used to obtain the location and
name of the significant cofactors.

\clearpage
\begin{figure}[ht]
<<fig=TRUE>>=
# plot MQM backward elimination with scanone
plot(result, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors with cofactors at every fifth
marker for \mqm\, followed by backward elimination
($cofactor.significance = 0.02$)}
\label{Backward2}
\end{figure}

\mqm\ \qtl\ mapping may result in many significant markers, with even multiple 
hits on each chromosome. Figure \ref{Backward2} shows that at 
$cofactor.significance=0.02$ chromosomes 1,2,4,5,6 and 15(?) are involved. 
Lowering the significance level from 0.02 to 0.002 may yield a smaller model. 
In biology extensive models are sometimes prefered, but in general a simpler 
model is more easily understood and, perhaps, validated. Increasing 
this significance level (hopefully) has the advantage 
that we can be more sure of the \qtl. 

\begin{figure}[ht]
<<fig=TRUE>>=
# plot lowered cofactor.significance
result <- mqm(hyperaug, cofactorlist, cofactor.significance=0.002)
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result))
plot(result)
@
\caption{\hyperintro, initially with cofactors at every fifth marker; after backwards elimination ($cofactor.significance = 0.002$).
}
\label{FigLowAlpha}
\end{figure}
\clearpage

When comparing the \mqm\ scan in figure \ref{FigLowAlpha} with the original
$scanone$ result in figure \ref{NoCofs} there are some striking differences.
Some \qtl\ show higher significance (LOD scores) and some others show lower
significance and are, therefore, estimated to be less likely involved in this
trait.

A figures can be reconstructed from a result ($scanone$ object) using the
$mqmplot\_one$ function (see for example figure \ref{AutoCofactor}). Here the
model and \qtl\ profile are retrieved.  These functions can only be used with
\mqm\ scans, as they have an additinal column $info$ which contains a QTL
model. The info column contains the estimated information content per marker.
$info$ is calculated from the deviation of the ideal marker distribution. For
example, in a recombinant inbred line we have most power when both groups (A
and B) have 125 mice, and no power when we have 1 A versus 249 B. Therefore we
can multiple the estimated QTL effect by this value \"to clean\" the QTL
profile by giving less weight to less informative markers.

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_one(result, extended=TRUE)
@
\caption{\hyperintro, initially with cofactors at every fifth marker; after backward elimination ($cofactor.significance = 0.002$). Figure plotted using $mqmplot\_one$ function.
}
\label{AutoCofactor}
\end{figure}

\section{MQM effects}

We can add the current effect to the mqmplots that are created by 
using the function $mqmplot\_directedqtl$. To use this function 
firstly we must have the $outputmarkers$ parameter when scanning 
using mqm set to true (true is the default value).
We can also manually extract the markers from the output of the mqmscan using 
$mqmextractmarkers(result)$. Then we call the plotting function 
which internaly adds the sign of the effect to the LOD score of 
the marker, and calls the standard R/qtl plotting functions. An example
can be found in figure \ref{QTLeffects}.

%\begin{figure}[ht]
%<<fig=TRUE>>=
%dirresults <- mqmplot_directedqtl(hyperaug,result)
%@
%\caption{Same as figure \ref{AutoCofactor}, but with effect sign 
%added to the QTL profile.
%}
%\label{QTLeffects}
%\end{figure}

Figure \ref{FigLowAlpha} implies that chromosomes 1, 2, 4 and 5 are
associated with high bloodpressure. If we want to investigate the
effects of the peek we can use \rqtl\ standard plotting tools to
visualize $main$ and/or $epistatic$ effects. The following code will plot
those two plots on markers "D1Mit102" (main effect) and the
interaction between "D1Mit102" and "D5Mit213" to show the $main$
effect and the estimated $epistasis$. These markers are initially
chosen because they are considered significant, based on mathematical
distributions used by \mqm\ (we will show a better method, based on
permutations, later). We set cofactors on chromosome 1 because these 
show the highest lod score when using the scan.one function.

To get an estimate of the effects of the QTLs we first investigate the effectplots.

\begin{figure}[ht]
<<fig=TRUE, results=hide>>=
plot.pxg(hyperaug,marker="D1Mit102")
@
\caption{Main effect of marker D1Mit102.}
\label{MainEffectsD1}
\end{figure}
The initial scans for high bloodpressure in figure \ref{Backward1}
possibly shows two \qtl\ on chromosome 1. The dual humped shape 
could be explained by an interaction between two QTLs on that chromosome. 
But there are other explainations for these kind of curves. We 
can however find out if there is an interaction on chromosome 
1 by using the effectplot function. To investigate the possible 
interaction we select markers "D1Mit19" (significant in figure \ref{Backward1}) 
and "D1Mit102" (significant in figure \ref{Backward2} and
\ref{AutoCofactor}) and make an effectplot.

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit19", mname2="D1Mit102")
@
\caption{With $effectplot$ the user can discover a possible epistatic effects between markers. Here an example using 
markers D1Mit19 and D1Mit102, (which show a slight interaction).}
\label{epistatic1}
\end{figure}

If we, for example, are interested in the interactions between
chromosome 1 and 5, we could make interaction plots between the two
markers with a high LOD score on those chromosomes by using the effect
plot:

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit102", mname2="D5Mit213")
@
\caption{$effectplot$ for discovering an epistatic effect of markers D1Mit102 and D5Mit213}
\label{epistatic2}
\end{figure}

Figure \ref{epistatic1} shows some evidence for an interaction between the two
markers D1Mit102 and D5Mit213, as both lines are non parallel. The two loci 
'x' and 'y' influence the trait in a significant way (because they are selected 
as cofactors by the mqm routine). If the effect shows two parallel lines the 
effect of both loci would be independant of eachother. This means no significant 
interaction between x and y. While non-parallel lines would indicate that the 
genotype on location y effects the influence of genotype x on the trait.
Interactions like these (epistatic ones) are prime wetlab candidates, and 
tell us the biology behind the QTLs.

\clearpage

\section{Permutation test for significance} 

\NOTE For all the examples in this section we use $25$ permutations. A real 
experiment uses - typically - $n.run=1000 to 10000$ tests with $b.size=25 to 500$
\\
\\
To estimate significance of the peeks ( and perhaps exclude some markers 
from our model ) we can use a permutation testing. This step is
computationally expensive - repeating the same test thousands of 
times on shuffled data to see what LOD scores come up in non associated data. 
If you have access to multiple CPUs on your computer you can install the 
SNOW package \cite{tierney03}\cite{tierney04}, which allows parallel 
computations on multiple CPU (cores). For small sets, with a limited amount 
of classical traits, the $mqmpermute$ works well. For large genome wide 
association studies (GWAS) use $mqmscanfdr$ to estimate the FDR across the entire
dataset at \lod\ cutoffs levels.
Both routines share some parameters: like $b.size$ the batchsize per core. 
If we set 100 permutations using 4 cores and a batchsize of 10, each core 
gets 10 traits to calculate QTL profiles on. 
When QTL modeling and mapping is done for these 10 traits. Another 10 traits are 
send to the core, untill all 100 traits have been analyzed. 
In $mqmpermutate$ we do single trait permutations not taking correlation between 
the traits into account. This has the advantage that for each peek in the profile 
above the significance level we can provide a confidence interval. First we need to 
convert the output to R/qtl format using the $mqmprocesspermutation$ function. The 
resulting object is of class $scanoneperm$ and can be used by the standard R/qtl 
functions for further analysis. 
<<>>=
require(snow)
results <- mqmpermute(hyperaug,cofactors=cofactorlist,n.clusters=2,n.run=25,b.size=25)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_permutations(results)
@
\caption{Calculate significance permuting 25 times over the hyper dataset. 
\qtl\ with a \lod\ higher than
2.5 LOD score can be considered significant (at $cofactor.significance=0.05 (green)$ or $cofactor.significance=0.10 (blue)$).
This is estimated from permuting a single trait. Chromosomes are signified by the gray gridlines.
}
\end{figure}
<<>>=
resultsrqtl <- mqmprocesspermutation(results)
summary(resultsrqtl)
@

To estimate false discovery rates in large sets, we need to do a whole genome 
permutation using $mqmscanfdr$. This method does take 
correlation between traits into account and gives an unbiased estimate 
of FDR at different thresholds (userspecified). This function scans the 
traits and counts observed \qtl\ (markers with a LOD above $x$) when setting a certain
threshold. It permutes all the data leaving the correlation structure
between traits intact. For this small example very high FDR estimates
are calculated because of the small amount of permutations and the
high correlation between traits. We thus discover many QTLs that map 
to the same location, this could normally only happen when we have an 
information sparse marker, or correlated traits as we ussually see in 
microarray experiments.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
mqmscanfdr(multifilled,mqmall,cofactors=cofactorlist,n.clusters=2)
@
\section{MQM and multiple traits}

MQM can analyse multiple traits simultaneously. 
Start by loading a new dataset ($multitrait$). $multitrait$
consists of an arabidopsis RIL cross with 24 metabolites measured (phenotypes).
Of these 24 phenotypes we will only scan the first 5 phenotypes this 
can be done using the $pheno.col$ parameter. To map back the possible 
regulatory locations of these metabolites one can use plain scanning of
all metabolites (initially without cofactors). Next plot all the profiles
in a heatmap. In this heatmap the colors represent the LOD score, on
the x-axis the marker number and on the y-axis the metabolite. The traits
are numbered in the plot. Plot heatmap without cofactors and then the
heatmap with cofactors and backward elimination. The plots show
improvement of the signal to noise ratio.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
resall <- mqm(multifilled,pheno.col=c(1,2,3,4,5),n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_multitrait(resall,"I")
@
\caption{Heatmap of 25 metabolite expression traits in arabidopsis, profiles created using mqm with no cofactors.}
\end{figure}
\clearpage
<<>>=
cofactorlist <- mqmsetcofactors(multifilled,3)
resall <- mqm(multifilled,pheno.col=c(1,2,3,4,5),cofactors=cofactorlist,n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_multitrait(resall,"I")
@
\caption{Heatmap of 25 metabolite expression traits in \At\ with profiles
created using cofactors at each third marker. Compared to figure 18 the
profile is clearer, because the individual profiles contain less noise.}
\end{figure}
Use $mqmplot\_nice$ for more graphical output. (This does not show in the
generated PDF, but in R it shows the trait profiles)
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_nice(resall,legendloc=1)
@
\caption{Results of scanning 25 traits using \mqm\ cofactors at each third marker}
\end{figure}

\clearpage
The next plot is the $mqmplot\_cistrans$ function. This plot is only available 
when genomic locations of the traits are known. By dafault the R/qtl cross
object does not store this data. So the user has to add this to the $cross$ object 
using the addloctocross function. After this operation the cis\_trans plot can be created
for \qtl\ with associated genome locations (For example when one is doing an
expression QTL analysis (eQTL). in these eQTL experiments the probes on the 
microarray have a genetic location).  The two axis of the cistrans plot both 
show the genetic location. The x-axis is, normally, the \qtl\ location and 
the y-axis the locations of the traits (e.g. a microarray probe).
Make sure not to forget to add the genomic locations need to be associated with the
$cross$ object.

\begin{figure}[ht]
<<fig=TRUE>>=
data(locations)
multiloc <- addloctocross(multifilled,locations)
mqmplot_cistrans(resall, multiloc, 5, FALSE, TRUE)
@
\caption{mqmplot\_cistrans, available when \qtl\
have associated genome locations. \qtl\ are plotted against the position on the
genome they were measured (here mQTL for \At), cutoff is at a lod score of 5
}
\end{figure}

\clearpage

\section{Overview of all \mqm\ functions}
\begin{table}[ht]
	\caption{Added functionality}
	\centering
	\begin{tabular}{| l | c | }
	\hline
	mqmaugment:& mqm data augmentation \\
	mqm(scan):& mqm modeling and scanning \\
	mqmsetcofactors:& Set cofactors at these markers (or every x marker) \\
	which.marker:& Change markernumbering into mqmformat \\
	mqmall:& mqmall to scan all traits using mqm\\
	mqmpermutate:& Single trait permutation \\
	mqmscanfdr:& Genome wide False Discovery Rates \\	
	mqmprocesspermutation:& Creates an R/qtl permutationobject \\
                & from the output of the $permute$ function \\
	mqmplot\_multitrait:& plotting of multiple traits (MQMmulti object) \\
	mqmplot\_nice:& plotting of mutiple traits (MQMmulti object) \\
  mqmplot\_directedqtl:& Plotting of signle trait with added qtl effect\\
	mqmplot\_boot:& plot methode to show single trait permutations \\
	mqmplot\_one:& plotting of single trait analysis with information content \\
	mqmplot\_cistrans:& Genomewide plot of cis- and transQTLs above a threshold \\
  addloctocross:& Adding genetic locations for traits \\	
	mqmtestnormal:& Tests the normallity of a trait \\ 	
	\hline
	\end{tabular}
	\label{tbl:tabel1}
\end{table}

\clearpage

\section{Final notes}

\subsection{Sex Chromosomes}

The current version of \mqm\ does not treat the sex chromosome as a
special case. You can treat sex as a covariate, of course, but special
recombination rates are not considered. This will change in a future
version.

\subsection{Out of memory}

When using a slack augmentation setting the matrix may grow out of
memory. You will see the following error:\\
\\
ERROR: Dataset too large after augmentation

When this happens please reload your crossobject from file and rerun the mqmaugmentation routine with:\\
1) set $minprob$ parameter higher (closer to 1)\\
2) allow for more augmentations per individual\\
3) allow for more augmentations in total\\
When dealing with a lot of missing markers (This message already shows when $minprob$ is equal to 1), the basic fill.geno
function from R/qtl can be used.

\clearpage

\begin{thebibliography}{9}
	\bibitem{broman09}
		Broman, K.W.; 2009.
		\emph{A brief tour of R/qtl}
		http://www.rqtl.org, R/qtl tutorials.
  \bibitem{rqtlbook}
    Karl W. Bromand and Saunak Sen.	  	  
	  \emph{A Guide to QTL Mapping with R/qtl}
    Springer, 2009
	\bibitem{broman03}
		Broman, K.W.; Wu, H.; Sen, S.; Churchill, G.A.; 2003.
		\emph{R/qtl: QTL mapping in experimental crosses}
		Bioinformatics, 19:889-890.
	\bibitem{jansen07}
		Jansen R. C.; 2007.
		\emph{Chapter 18 - Quantitative trait loci in inbred lines} 
		Handbook of Stat. Genetics 3th edition,(c) 2007 John Wiley \& Sons, Ltd.
	\bibitem{tierney04}	
		Tierney, L.; Rossini, A.; Li, N.; and Sevcikova, H.; 2004.
		\emph{The snow Package: Simple Network of Workstations} Version 0.2-1. 
	\bibitem{tierney03}
		Rossini, A.; Tierney, L.; and Li, N.; 2003.
		\emph{Simple parallel statistical computing}
		R. UW Biostatistics working paper series University of Washington. 193
	\bibitem{jansen01}	
		Jansen R. C.; Nap J.P.; 2001
		\emph{Genetical genomics: the added value from segregation}
		Trends in Genetics, 17, 388-391.
	\bibitem{jansen94}		
		Jansen R. C.; Stam P.; 1994
		\emph{High resolution of quantitative traits into multiple loci via interval mapping}
		Genetics, 136, 1447-1455. 
	\bibitem{Churchill94}
		Churchill, G. A.; and Doerge, R. W.; 1994
		\emph{Empirical threshold values for quantitative trait mapping}
		Genetics 138, 963–971. 
	\bibitem{jansen93}
		Jansen R. C.; 1993
		\emph{Interval mapping of multiple quantitative trait loci}
		Genetics, 135, 205–211.
	\bibitem{Dempster77}
		Dempster, A. P.; Laird, N. M. and Rubin, D. B.; 1977 
		\emph{Maximum likelihood from incomplete data via the EM algorithm}
		J. Roy. Statist. Soc. B, 39, 1–38.
\end{thebibliography}
\end{document}
