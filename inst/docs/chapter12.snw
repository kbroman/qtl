\documentclass[11pt]{article}
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{23.5cm}
\setlength{\textwidth}{17.0cm}
\setlength{\oddsidemargin}{.025in}
\setlength{\evensidemargin}{.025in}
\setlength{\textwidth}{6.25in}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{Sweave}

\newcommand{\mqm}{\emph{MQM}}
\newcommand{\MQM}{\mqm}
\newcommand{\qtl}{QTL}
\newcommand{\QTL}{\qtl}
\newcommand{\lod}{LOD}
\newcommand{\cM}{cM}
\newcommand{\rqtl}{\emph{R/qtl}}
\newcommand{\cim}{\emph{CIM}}
\newcommand{\At}{\emph{Arabidopsis thaliana}}
\newcommand{\FIXME}{({\bf FIXME!})}
\newcommand{\CHECK}{({\bf CHECK!})}
\newcommand{\NOTE}{({\tt NOTE: })}
\newcommand{\hyperintro}{\qtl\ profiles of the hyper dataset with the trait bp (blood
pressure) in an experiment with 250 mice using \mqm}
\newcommand{\hyperintrocolors}{ \qtl\ profiles of the hyper dataset with the trait bp (blood pressure) in an experiment with 250 mice comparing \mqm\ (black) and
scanone (green)}

\title { Chapter 12 - Multiple QTL Model (MQM) Analysis }
\author { Danny Arends, Pjotr Prins, Karl Broman and Ritsert Jansen }
\begin {document}
\maketitle
\clearpage

\section{Introduction}

\mqm\ allows the mapping of QTL using an automated model selection method, as
described by R.C. Jansen\cite{jansen94}. \mqm\ is part of
\rqtl\cite{broman09}\cite{broman03} and consists of a three step procedure
consisting of (1) data augmentation, (2) automatic backward model elimination using genetic
markers as cofactors and (3) QTL (interval) mapping using the most
'informative' model. The method internally controls false discovery rates (FDR) and
lets users test different QTL models by elimation of non-significant
cofactors\footnote{We assume the reader knows how to load his data into R using
the R/qtl $read.cross()$ function}.

\input{mqm/limitations.txt}

Still, \mqm\ is a valuable addition to the \qtl\ mapper's toolbox. It
is able to deal with interference of \qtl, handles missing data and
allows more precise detection than other methods. This tutorial will
show how to use \mqm\ for \qtl\ mapping. Also R/qtl's \mqm\ is fast
and scales on multi-CPU systems.

\section{A quick overview}

These are the steps in an \mqm\ \qtl\ analysis
\itemize{
\item Load in experiment using formats supported by R/QTL
\item Set trait under consideration as first trait in R/QTL format
\item Fill in missing data using either the fill.geno or mqmaugmentdata routine
\item Call mqmscan to do a genomescan
\item Call mqmscan setting the n.run to get an estimate of "significant" lod scores
\item Set cofactors at "Top scoring" and not so "Top scoring" markers
\item Rerun analysis with cofactors
\item Bootstrap analysis with cofactors to get estimates of QTL significance
}
Using ML or Reduced ML the algorithm employs a backward selection strategy to identify QTL hotspot. The algorithm passes through the following stages:
\itemize{
\item Calculating relative marker positions
\item (Re)Estimating recombinant frequencies
\item LOGlikelyhood estimations of the full model using all cofactors
\item IF(Cofactors) THEN Backward elimination of cofactors \& mapQTL
\item IF(No cofactors) THEN mapQTL function
}
Afterwards the Interval mapping of the QTL model is returned to the user

\section{Data augmentation}

\FIXME the augmentation procedure is still not conclusive - and therefor 
the description below is not completely correct.

Most real genetic marker data is incomplete. \mqm\ automatically
expands the dataset by adding all potential variants and attaches a
likelihood to them.  For example, information is missing (unknown) at
a marker location in one individual. Based on the values of the
neighbouring markers, a likelihood is attached to a marker being, for
example, either A or B.  With \mqm\ all likely options are considered.
When genotypes A and B are possible at the location two 'individuals'
are created in the augmentation step, one with genotype A, and one
with genotype B. A probability is attached to either variant. The
combined probabilities of all markers tells us whether a combination
of variants is likely, or not.

To see an example of missing data with an F2 intercross, we can
visualize the genotypes of the individuals using $plot.geno$ In figure
\ref{missing data} there are 2\% missing values in white. The other
colors stand for genotypes at a certain position for a certain
individual. We can simulate an F2 dataset with 2\% missing markers as
follows:

<<>>=
library(qtl)
data(map10)
mycross <- sim.cross(map10, type="f2", n.ind=100, missing.prob=0.02)
@
\begin{figure}[ht]
<<fig=TRUE>>=
geno.image(mycross)
@
\caption{Simulate an F2 cross with 2\% missing data starting from the
map10 F2 intercross. The figure
displays genotypes of 100 individuals with around 2\%
missing data for the map10 F2 intercross}
\label{missing data}
\end{figure}

Before we can go to the next step (scanning for QTL using linear
regression), the data has to be completed (i.e. no more missing markers).
There are two possibilities: either use fill.geno or augmentation with
$mqmaugment$. With $fill.geno()$ the most likely genotype is filled in
using multiple imputations, estimating the missing marker genotypes.
In contrast augmentation introduces all variants. At this stage
$mqmaugment$ is specific to \mqm \footnote{Note that after
augmentation the resulting cross object is no longer suitable for the
use with $scan.one$ or \cim, because of the additional information
stored}. 

Here we use \mqm's augmentation. The function $mqmaugment()$ can fill in
missing genotypes for us. For each missing marker it fills in all possible
marker locations with all genotypes and calculates their probability. When they
are more likely than the $minprob$ parameter the \emph{augmented}
individual is stored in the new $crossobject$, ready for QTL mapping.
\footnote{Note at this point the $mqmaugment()$
function can only handle one phenotype at the time even though augmentation is
independent of the phenotype. This will be changed in an upcoming release of
R/qtl with \mqm}

The important parameters are: $cross, pheno.col, maxaugind, minprob$
and $verbose$. $maxaugind$ sets the maximum number of \emph{augmented} genotypes
per individual in a dataset. The default of 60 is usually good enough (20
missing F2 markers or 30 missing BC markers per individual). However higher numbers could be needed 
when there are more missing markers. Each individual is
augmented with a probability of, at least, $minprob$ -
i.e. only augment genotypes that of individuals that are above a probability of occurring (and drop
the less likely cases). Note that setting this value too low may result in dropping
individuals entirely. Use the verbose option to get more feedback on the augmentation routine.

<<>>=
# displays warning because MQM ignores the X chromosome in an F2
augmentedcross <- mqmaugment(mycross, minprob=1)
@
\begin{figure}[ht]
<<fig=TRUE>>=
plot.geno(augmentedcross)
@
\caption{$plot.geno$ showing the genotypes of 100 individuals with no missing
values ($mqmaugment$ with $minprob=1$ means we fill in the 
most likely genotypes at each marker, no expansion of the dataset takes place}
\end{figure}

With a lower $minprob$ value less likely genotypes are also
considered and the resulting \emph{augmented} dataset will be larger. Unfortunately, 
at this stage, the expanded dataset can not be used with scanone as it treats the extra individuals as new
individuals, while \mqm\ recognises expanded individuals as 
single entities. The (weighted) augmented individuals with all possible genotypes leads to a 
more accurate mapping when dealing with missing values and give a smoother \qtl\ profile, leading to a more accurate mapping.
\cite{jansen93}.

\begin{figure}[ht]
<<fig=TRUE>>=
augmentedcross <- mqmaugment(mycross, minprob=0.1)
plot.geno(augmentedcross)
@
\caption{$plot.geno$ showing the augmented genotypes of 100 individuals with no
missing values. There are 340 individuals in this plot, because \mqm\ expands
the dataset when filling in missing markers (an average expansion of 3.4 per
individual).}
\end{figure}

\clearpage

\section{QTL modelling and mapping with MQM}

The \emph{hyper} dataset is a backcrossed offspring of mice with two traits in the
dataset: bloodpressure (bp) and sex. Here we show an example of running both
single marker QTL (scanone) and \mqm\ QTL mapping routinges to analyse the blood 
pressure trait.

% \texttt{qtl.mqm} help page into a \LaTeX{} document

<<>>=
data(hyper)
colors <- c("Black","Green")
lines <- c(2,1)
hyperaug <- mqmaugment(hyper, minprob=1)
result_nocof <- mqm(hyperaug)
result_scanone <- scanone(hyperaug)
@
We start bij loading the dataset using the command $data(hyper)$. We fill in missing 
genotypes using the mqmaugment routine discussed before. Then scan for QTLs using 
mqmscan and scanone with default parameters. A plot comparing the two scanning methods 
to eachother can be found in figure \ref{NoCofs}. We see that the plot of the results from both scans
(black=mqm, green=scanone) show an almost 1 to 1 correspondence. When we look at the output 
from the two methods we see that MQM doesn't have the original markers listed. This is because 
MQM uses intervall mapping. Each chromosome is divided into fictional markers spaced xx Cm apart.
The xx can be set by the user using the stepsize parameter. A LOD score for underlying QTLs is 
calculated at these 'fictional' markers. Using the intervall mapping approach we obtain smoother 
profiles than compared to markerbased mapping approaches (when using a small stepsize).

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result_nocof, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors. Both routines
correspond one to one when using no extra parameters}
\label{NoCofs}
\end{figure}

To use the automatic model selection in \mqm\ we first need to supply the algorithm with an initial model.
This initial model can be produced in two ways: (1) Building a model by hand (Forward stepwise), or
(2) use unsupervised backward elimination on a large number of markers.  

First it will be explained how to build the initial model by hand, using a forward stepwise approach.
A model consists of markers we want to account for, like we would account for sex as an 
external variable influencing our results. We start building the initial model by adding cofactors at 
markers with high LOD scores. figure \ref{NoCofs} shows a large QTL peek on chromosome 4 at 30 \cM, 
so let's account for that by setting a cofactor at the marker nearest to the peek on chromosome 4. 
This is achieved by the following code and a new mqm scan is performed (figure \ref{Cofactor4}).
<<>>=
#Summary results shows the highest lodscores per chromosome
summary(result_nocof)
#find.marker extracts the marker nearest to chr4 at 30Cm
find.marker(hyperaug,chr=4,pos=30)
#which.marker translates the name into a cofacotr number
toset <- which.marker(hyperaug,"D4Mit164")
cofactorlist <- mqmcofactors(hyperaug,toset)
#scan again
result_1 <- mqm(hyperaug, cofactorlist)
@
\begin{figure}[ht]
<<fig=TRUE>>=
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result_1))
plot(result_1)
@
\caption{\hyperintro.  A cofactor is added at chromosome 4 (D4Mit164) and kept in the
model. The LOD score (evidence) for a second QTL on chromosome 1 increases.
} 
\label{Cofactor4}
\end{figure}

Figure \ref{Cofactor4} shows the effect of setting a single marker as a
cofactor related to the \qtl\ on chromosome 4, followed by an \mqm\ scan.
The marker is not dropped and it passes initial rough thresholding to account
for the, user defined, alpha level. It is therefore used in the mappingphase 
of the mqm routine. We expect LODscores to change (slightly) genomewide because 
we account for variation already explained by the QTL on chromosome 4. We can 
show this change in LOD scores by plotting these new results against the mqm 
\qtl\ mapping without cofactors.

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result_1, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactor at chromosome 4 (D4Mit164) to account for variation explained by that
marker.}
\end{figure}

The second peek on chromosome 1 at 70 \cM\ increases, so try adding that to the
model and check if the model with both cofactors changes the \qtl. Combining
$which.marker$ with $find.marker$, the new cofactornumber $c$ with the cofactor
already in $toset$. When using the function mqmcofactors or mqmsetcofactors, the 
number of cofactors the user is trying to set is compared against the number of 
individuals inside the cross object. If there is any danger of overfitting the 
model the function will error and not return a cofactorlist. Also inside MQM the 
residual degrees of freedom left are checked to make sure also 'usercreated' 
cofactorlists do not overfit the modeling routine.

<<>>=
summary(result_1)
#we can combine find marker and which.marker commands and expand our toset variable
toset <- c(toset,which.marker(hyperaug,find.marker(hyperaug,1,70)))
cofactorlist <- mqmcofactors(hyperaug,toset)
result_2 <- mqm(hyperaug, cofactorlist)
@
\begin{figure}[ht]
<<fig=TRUE>>=
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result_2))
plot(result_2, result_1, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactors at chromosomes 1 and 4 we see just a tiny difference in the likeyhood 
scores for each chromosome. The LOD scores don't seem to improve much after adding
 another cofactor on chromosome 4. But lets take a closer look }
\label{twowaycomparison}
\end{figure}

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result_nocof, result_1, result_2,chr=c(1,11,15),col=c("black","red","blue"),lwd=c(3,2,1))
@
\caption{Comparison between the last scans. We see here a closeup of chromosome 1
scanned using mqm with 3 different cofactor settings: MQM using no cofactors, 
MQM using a single cofactor on chromosome 4 (Red) and MQM using cofactors on chromosome 1 and 4.(Blue) 
We see the LOD scores on chromosome 1 increasing when including more cofactors.}
\label{threewaycomparison}
\end{figure}
\clearpage

\mqm\ checks that no markers are included that are less significant than the
alpha level specified by the user. The marker on chromosome 1 is also informative 
enough to be included into the model. Thus creating a new initial model consisting 
of cofactors on chromosome 4 and 1). This process of selection of cofactors can 
continue untill there are no more informative markers that can be included. Practically 
this means one keeps on adding cofactors untill the newest added cofactor gets dropped from the model.

This manually looking into the profile and determining at which marker to set a cofactor
could be very time consuming in the case of many QTLs underlying a trait.
\mqm\ also provides unsupervised backward elimination (or elimination) on a large
number of markers by setting cofactors at every other marker. The algorithm
will analyse all the markers and if one is found to be not informative enough
it drops it from the model. This step is repeated until a limited number of
significant cofactors is left.

After backwards elimination it will scan each chromosome using the model that
includes the retained cofactors. Set the plot parameter to TRUE ($plot=T$) to
get a graphical view of the model. Here we set a cofactor at every fifth
marker, and assess which chromosomes may be implicated in high bloodpressure.
Specify the cofactor at every 5 markers by using the $mqmsetcofactors()$ function

<<>>=
cofactorlist <- mqmsetcofactors(hyperaug,5)
result <- mqm(hyperaug, cofactorlist, plot=T)
@
\begin{figure}[ht]
<<fig=TRUE>>=
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result))
plot(result)
@
\caption{\hyperintro, after introducing cofactors at every fifth marker and
backward eliminatio to find the most likely model}
\label{Backward1}
\end{figure}
<<>>=
mqmgetmodel(result)
@
The $mqmgetmodel()$ function returns the model from the resulting $scanone$ object.
The model will be returned in R/qtl model format and can be used with the scan.two 
function from R/qtl. This is only available when doing automatic backward elimination. 
The resulting model can also be used to obtain the location and name of the significant markers.

\clearpage
\begin{figure}[ht]
<<fig=TRUE>>=
plot(result, result_scanone, col=colors, lwd=lines)
@
\caption{\hyperintrocolors with cofactors at every fifth
marker for mqm, followed by backward elimination
(alpha = 0.02). The resulting profiles are clearly different }
\label{Backward2}
\end{figure}

This \mqm\ QTL mapping results in a lot of significant markers, with even multiple 
hits on each chromosome. Figure \ref{Backward2} shows us that at an alpha of 0.02 
chromosomes 1,2,4,5,6 and (15?) are involved. Lowering the significance level from 
0.02 to 0.002 may yield a smaller model. In biology extensive models are sometimes 
prefered, but in general a simpler model is more easily understood and verified in 
the wetlab. Increasing the significance level (and simplifying the model) also has 
the advantage that we can be more sure of the QTLs we do report. we can set this 
bij using the parameter: cofactor.significance

\begin{figure}[ht]
<<fig=TRUE>>=
result <- mqm(hyperaug, cofactorlist, cofactor.significance=0.002)
op <- par(mfrow = c(2,1))
plot(mqmgetmodel(result))
plot(result)
@
\caption{\hyperintro, intially with cofactors at every fifth marker; after backwards elimination (alpha = 0.002).
}
\label{FigLowAlpha}
\end{figure}
\clearpage

When comparing the \mqm\ scan in figure \ref{FigLowAlpha} with the original
$scanone$ result in figure \ref{scanone} there are some striking differences.
Some \qtl\ show higher significance (LOD scores) and some others show lower
significance and are, therefore, estimated to be less likely involved in this
trait.

To replot the plots created during \mqm\ analysis is also possible. The figures can be 
reconstructed from resulting $scanone$ object using $mqmplot_one(result)$ see figure 
\ref{AutoCofactor}. This retrieves the model and the QTLprofile from the result 
objectattribute $mqmgetmodel(result)$. The functions can only be used with \mqm\
scans, as they have an additinal column $info$ and contain a QTLmodel. The info 
column contains the estimated information content per marker. $info$ is calculated 
from the deviation of the ideal marker distribution. For example, in a recombinant 
inbred line we have most power when both groups (A and B) have 125 mice, and no power 
when we have 1 A versus 249 B. Therefore we can multiple the estimated QTL effect by 
this value \"to clean\" the QTL profile by giving less weight to less informative markers.

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_one(result)
@
\caption{\hyperintro, initially with cofactors at every fifth marker; after backward elimination (alpha = 0.002). Figure plotted using $mqmplot_one$.
}
\label{AutoCofactor}
\end{figure}

\section{MQM effects}

Figure \ref{FigLowAlpha} implies that chromosomes 1, 2, 4 and 5 are
associated with high bloodpressure. If we want to investigate the
effects of the peek we can use \rqtl\ standard plotting tools to
visualize $main$ and/or $epistatic$ effects. The following code will plot
those two plots on markers "D1Mit102" (main effect) and the
interaction between "D1Mit102" and "D5Mit213" to show the $main$
effect and the estimated $epistasis$. These markers are initially
chosen because they are considered significant, based on mathematical
distributions used by \mqm\ (we will show a better method, based on
permutations, later). We set cofactors on chromosome 1 because these 
show the highest lod score when using the scan.one function.

To get an estimate of the effects of the QTLs we first investigate the effectplots.

\begin{figure}[ht]
<<fig=TRUE, results=hide>>=
plot.pxg(hyperaug,marker="D1Mit102")
@
\caption{Main effect of marker D1Mit102.}
\label{MainEffectsD1}
\end{figure}
The initial scans for high bloodpressure in figure \ref{Backward}
possibly shows two \qtl\ on chromosome 1. The dual humped shape could be explained by
an interaction between two QTLs on that chromosome. But there are other explainations 
for these kind of curves. We can however find out if there is an interaction on chromosome 
1 by using the effectplot function. To investigate the possible interaction we select markers "D1Mit19" (significant
in figure \ref{Backward1}) and "D1Mit102" (significant in figure \ref{Backward2} and
\ref{AutoCofactor}) and make an effectplot.

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit19", mname2="D1Mit102")
@
\caption{With $effectplot$ discover a possible epistatic effect of
markers D1Mit19 and D1Mit102.}
\label{epistatic1}
\end{figure}

If we, for example, are interested in the interactions between
chromosome 1 and 5, we could make interaction plots between the two
markers with a high LOD score on those chromosomes by using the effect
plot:

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit102", mname2="D5Mit213")
@
\caption{$effectplot$ for discovering an epistatic effect of markers D1Mit102 and D5Mit213}
\label{epistatic2}
\end{figure}

Figure \ref{epistatic1} shows some evidence for an interaction between the two
markers D1Mit102 and D5Mit213, as both lines are non parallel. Imagine two loci x and y influencing a trait. Parallel lines denote 
no significant interaction between x and y. While non-parallel lines mean the genotype on location y has an effect 
on the effect of the genotype at location x.

\clearpage

\section{Permutation test for significance} 

To estimate significance of the peeks ( and perhaps exclude some markers from our model ) we can use a permutation test. This can be
computationally expensive - repeating the same test thousands of times. If you have access to multiple CPUs on your
computer you can install the SNOW package
\cite{tierney03}\cite{tierney04}, which allows parallel computations on multiple CPU (cores). For small sets, with a limited amount
of traits, the $mqmpermute()$ works well. For large genome wide association studies
(GWAS) use $mqmscanfdr()$ to estimate the FDR across the entire
dataset
at certain \lod\ cutoffs (for this example we use $25$ permutations, for
a real experiment use - typically - $1000$ tests with $b.size=25$ or $50$). b.size is the batchsize per core. If we set 100 permutations using 4 cores and a batchsize of 10, each core gets 10 traits to calculate QTL profiles on. When done another 10 traits are send to the core, untill all 100 traits have been analyzed. In mqmpermutate we do single trait permutations not taking correlation between the traits into account. If we want to estimate false discovery rates, we need to do a whole genome permutation using mqmscanfdr. This method does take correlation between traits into account and gives an unbiased estimate of FDR at different thresholds (userspecified)

\begin{figure}[ht]
<<>>=
require(snow)
results <- mqmpermute(hyperaug,cofactors=cofactorlist,n.clusters=2,n.run=25,b.size=25)
@
<<fig=TRUE>>=
mqmplot_permutations(results)
@
\caption{Calculate significance permuting 25 times over the hyper dataset. 
\qtl\ with a \lod\ higher than
2.5 LOD score can be considered significant (at $alpha=0.05 (green)$ or $alpha=0.10 (blue)$).
This is estimated from permuting a single trait. Chromosomes are signified by the gray gridlines.
}
\end{figure}

For estimating false discovery rates use the function
$mqmscanfdr$. The function scans the traits and counts
observed \qtl\ (markers with a LOD above $x$) when setting a certain
threshold. It permutes all the data leaving the correlation structure
between traits intact. For this small example very high FDR estimates
are calculated because of the small amount of permutations and the
high correlation between traits. We thus discover many QTLs that map 
to the same location, this could normally only happen when we have an 
information sparse marker, or correlated traits as we ussually see in 
microarray experiments.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
mqmscanfdr(multifilled,mqmall,cofactors=cofactorlist,n.clusters=2)
@
\section{MQM and multiple traits}

MQM can analyse multiple traits simultaneously. 
Start by loading a new dataset ($multitrait$). $multitrait$
consists of an arabidopsis RIL cross with 24 metabolites measured (phenotypes).

Start by filling in the genome using the $fill.geno$ function, rather
than $mqmaugment$, which can only handle one trait. To map back the
possible regulatory locations of these traits use plain scanning of
all traits (initially without cofactors). Next plot all the profiles
in a heatmap. In this heatmap the colors represent the LOD score, on
the x-axis the marker number and on the y-axis the traits. The traits
are numbered in the plot. Plot heatmap without cofactors and then the
heatmap with cofactors and backward elimination. The plots show
improvement of the signal to noise ratio.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
resall <- mqm(multifilled,pheno.col=c(1,2,3,4,5),n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_multitrait(resall,"I")
@
\caption{Heatmap of 25 metabolite expression traits in arabidopsis, profiles created using mqm with no cofactors.}
\end{figure}
\clearpage
<<>>=
cofactorlist <- mqmsetcofactors(multifilled,3)
resall <- mqm(multifilled,pheno.col=c(1,2,3,4,5),cofactors=cofactorlist,n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_multitrait(resall,"I")
@
\caption{Heatmap of 25 metabolite expression traits in \At with profiles
created using cofactors at each third marker. Compared to figure 18 the
profile is clearer, because the individual profiles contain less noise.}
\end{figure}
Use $mqmplot\_nice$ for more graphical output. (This does not show in the
generated PDF, but in R it shows the trait profiles)
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplot_nice(resall,legendloc=1)
@
\caption{Results of scanning 25 traits using \mqm\ cofactors at each third marker}
\end{figure}

\clearpage
The next plot is the $mqmplot\_cistrans$ function. This plot is only available 
when genomic locations of the traits are known. By dafault the R/qtl cross
object does not store this data. So the user has to add this to the $cross$ object 
using the addloctocross function. After this operation the cis_trans plot can be created
for \qtl\ with associated genome locations (For example when one is doing an
expression QTL analysis (eQTL). in these eQTL experiments the probes on the 
microarray have a genetic location).  The two axis of the cistrans plot both 
show the genetic location. The X-axis is, normally, the \qtl\ location and 
the Y-axis the location of the trait (e.g. a microarray probe).
Make sure not to forget to add the genomic locations need to be associated with the
$cross$ object.

\begin{figure}[ht]
<<fig=TRUE>>=
data(locations)
multiloc <- addloctocross(multifilled,locations)
mqmplot_cistrans(resall, multiloc, 5, FALSE, TRUE)
@
\caption{mqmplot_cistrans, available when \qtl\
have associated genome locations. \qtl\ are plotted against the position on the
genome they were measured (here mQTL for \At), cutoff \lod\ 5}
\end{figure}

\clearpage

\section{Overview of all \mqm\ functions}
\begin{table}[ht]
	\caption{Added functionality}
	\centering
	\begin{tabular}{| l | c | }
	\hline
	mqmaugment:& mqm data augmentation \\
	mqm(scan):& mqm modeling and scanning \\
	mqmsetcofactors:& Set cofactors at these markers (or every x marker) \\
	which.marker:& Change markernumbering into mqmformat \\
	mqmall:& mqmall to scan all traits using mqm\\
	bootstrap (AKA permute):& Single trait permutation \\
	mqmscanfdr:& Genome wide False Discovery Rates \\	
	mqmpermObject:& Creates an R/qtl permutationobject from the output of the $permute()$ function \\
	mqmplot_multitrait:& plotting of multiple traits (MQMmulti object) \\
	mqmplot_nice:& plotting of mutiple traits (MQMmulti object) \\
	mqmplot_boot:& plot methode to show single trait permutations \\
	mqmplot_one:& plotting of single trait analysis with information content \\
	mqmplot_cistrans:& Genomewide plot of cis- and transQTLs above a threshold \\
  addloctocross:& Adding genetic locations for traits \\	
	mqmtestnormal:& Tests the normallity of a trait \\ 	
	\hline
	\end{tabular}
	\label{tbl:tabel1}
\end{table}

\clearpage

\section{Final notes}

\subsection{Sex Chromosomes}

The current version of \mqm\ does not treat the sex chromosome as a
special case. You can treat sex as a covariate, of course, but special
recombination rates are not considered. This will change in a future
version.

\subsection{Out of memory}

When using a slack augmentation setting the matrix may grow out of
memory. You will see the following error:\\
\\
ERROR: Dataset too large after augmentation

When this happens please reload your crossobject from file and rerun the mqmaugmentation routine with:\\
1) set $minprob$ parameter higher (closer to 1)\\
2) allow for more augmentations per individual\\
3) allow for more augmentations in total\\
When dealing with a lot of missing markers (This message already shows when $minprob$ is equal to 1), the basic fill.geno
function from R/qtl can be used.

\clearpage

\begin{thebibliography}{9}
	\bibitem{broman09}
		Broman, K.W.; 2009.
		\emph{A brief tour of R/qtl}
		http://www.rqtl.org, R/qtl tutorials.
	\bibitem{broman03}
		Broman, K.W.; Wu, H.; Sen, S.; Churchill, G.A.; 2003.
		\emph{R/qtl: QTL mapping in experimental crosses}
		Bioinformatics, 19:889-890.
	\bibitem{jansen07}
		Jansen R. C.; 2007.
		\emph{Chapter 18 - Quantitative trait loci in inbred lines} 
		Handbook of Stat. Genetics 3th edition,(c) 2007 John Wiley \& Sons, Ltd.
	\bibitem{tierney04}	
		Tierney, L.; Rossini, A.; Li, N.; and Sevcikova, H.; 2004.
		\emph{The snow Package: Simple Network of Workstations} Version 0.2-1. 
	\bibitem{tierney03}
		Rossini, A.; Tierney, L.; and Li, N.; 2003.
		\emph{Simple parallel statistical computing}
		R. UW Biostatistics working paper series University of Washington. 193
	\bibitem{jansen01}	
		Jansen R. C.; Nap J.P.; 2001
		\emph{Genetical genomics: the added value from segregation}
		Trends in Genetics, 17, 388-391.
	\bibitem{jansen94}		
		Jansen R. C.; Stam P.; 1994
		\emph{High resolution of quantitative traits into multiple loci via interval mapping}
		Genetics, 136, 1447-1455. 
	\bibitem{Churchill94}
		Churchill, G. A.; and Doerge, R. W.; 1994
		\emph{Empirical threshold values for quantitative trait mapping}
		Genetics 138, 963–971. 
	\bibitem{jansen93}
		Jansen R. C.; 1993
		\emph{Interval mapping of multiple quantitative trait loci}
		Genetics, 135, 205–211.
	\bibitem{Dempster77}
		Dempster, A. P.; Laird, N. M. and Rubin, D. B.; 1977 
		\emph{Maximum likelihood from incomplete data via the EM algorithm}
		J. Roy. Statist. Soc. B, 39, 1–38.
\end{thebibliography}
\end{document}
