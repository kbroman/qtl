\documentclass[11pt]{article}
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{23.5cm}
\setlength{\textwidth}{17.0cm}
\setlength{\oddsidemargin}{.025in}
\setlength{\evensidemargin}{.025in}
\setlength{\textwidth}{6.25in}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{Sweave}

\newcommand{\mqm}{\emph{MQM}}
\newcommand{\MQM}{\mqm}
\newcommand{\qtl}{QTL}
\newcommand{\QTL}{\qtl}
\newcommand{\lod}{LOD}
\newcommand{\cM}{cM}
\newcommand{\rqtl}{\emph{R/qtl}}
\newcommand{\At}{\emph{Arabidopsis thaliana}}
\newcommand{\FIXME}{({\bf FIXME!})}
\newcommand{\CHECK}{({\bf CHECK!})}
\newcommand{\NOTE}{({\tt NOTE: })}
\newcommand{\hyperintro}{\qtl\ profiles of the hyper dataset with the trait bp (blood
pressure) in an experiment with 250 mice using \mqm}
\newcommand{\hyperintrocolors}{ \qtl\ profiles of the hyper dataset with the trait bp (blood pressure) in an experiment with 250 mice comparing \mqm\ (black) and
scanone (green)}

\title { Chapter 12 - Multiple QTL Model (MQM) Analysis }
\author { Danny Arends, Pjotr Prins, Karl Broman and Ritsert Jansen }
\begin {document}
\maketitle
\clearpage

\section{Introduction}

\mqm\ allows the mapping of QTL using an automated model selection method, as
described by R.C. Jansen\cite{jansen94}. \mqm\ is an integrated part of
\rqtl\cite{broman09}\cite{broman03}. \mqm\ consists of a three step procedure
consisting of (1) data augmentation, (2) backward model elimination using genetic
markers as cofactors and (3) QTL (interval) mapping using the most
'informative' model. The method internally controls false discovery rates (FDR) and
lets users test extensive QTL models by elimation of non-significant
cofactors\footnote{We assume the reader knows how to load his data into R using
the R/qtl $read.cross()$ function}.

At the moment \mqm\ supports experimental crosses F2, RIL and BC. Also \mqm\
does nottreat sex chromosomes differently from autosomal - though one can
introduce sex as a cofactor. Another limitation is that \mqm\ handles one
phenotype at a time. Finally automatic backward elimination does not consider
marker density at locations. Future versions of \mqm\ may improve on this.

\section{Data augmentation}

In many cases genetic marker data is incomplete. \mqm\ automatically expands
the dataset by adding all potential variants and attaches a likelihood to them.
For example a genetical type is missing (unknown) at a marker location in one
individual. Based on the values of the surrounding available markers, a
likelihood is attached to a marker being, for example, either A or B. The
likely options are all considered in the model.

For example with an F2 intercross we can visualize the genotypes of the
individuals using plot.geno In figure \ref{missing data} there are 2\% missing
values in white. The other colors stand for genotypes at a certain position for
a certain individual. We can simulate an F2 dataset with 2\% missing markers as follows:

<<>>=
library(qtl)
data(map10)
mycross <- sim.cross(map10, type="f2", n.ind=100, missing.prob=0.02)
@
\begin{figure}[ht]
<<fig=TRUE>>=
geno.image(mycross)
@
\caption{geno.image showing the genotypes of 100 individuals with around 2\%
missing data for the map10 F2 intercross}
\end{figure}

Before we can start the next step of \mqm, the data has to be complete (no
missing markers). There are two possibilities: (1) fill.geno and (2)
augmentation. \rqtl's $fill.geno()$ fills in the most likely markers using
imputations to estimate the missing marker genotypes while augmentation is
specific to the \mqm\ procedure\footnote{Note that after augmentation the
resulting cross object is no longer suitable for the use with scan.one or cim,
because of the additional information stored}. 

Here we opt for \mqm's augmentation. The function $mqmaugment()$ can fill in
missing genotypes for us.  For each missing marker it fills in all possible
marker locations with all genotypes and calculates their likelihood. When they
are more likely than the $minprob$ parameter the \emph{augmented}
individual is stored in the new crossobject. At this point the $mqmaugment()$
function can only handle one phenotype at the time even though augmentation is
independent of the phenotype.  This will be changed in an upcoming release of
R/qtl with \mqm.

The important parameters are: $cross, pheno.col, maxaugind, minprob$
and verbose. $maxaugind$ sets the maximum number of \emph{augmented} genotypes
per individual in a dataset. The default of 60 is usually good enough (20
missing F2 markers or 30 BC markers per individual). However higher numbers could be needed 
when there are more missing markers. Each individual is
expanded (augmented) with a probability of, at least, $minprob$ -
i.e. only augment genotypes that are above a probability of occurring (and drop
lower probabilities). Note that setting this value too low may result in dropping
individuals entirely. Using the verbose option to get more feedback on the augmentation routine
is advised.
<<>>=
#warns because mqm doesnt handle the X chromosome yet
augmentedcross <- mqmaugment(mycross, minprob=1)
@
\clearpage
\begin{figure}[ht]
<<fig=TRUE>>=
plot.geno(augmentedcross)
@
\caption{$plot.geno$ showing the genotypes of 100 individuals with no missing
values (using $mqmaugment$). We used mqmaugment with $minprob=1$ this means we fill in the 
most likely genotypes at each marker, no expansion of the dataset takes place}
\end{figure}

With a higher $minprob$ value less likely genotypes are also
considered and the resulting \emph{augmented} dataset will be larger. Unfortunately, 
at this stage, the expanded dataset can not be used with scanone as it treats the extra individuals as new
individuals, while \mqm\ recognises expanded individuals as 
single entities. The (weighted) augmented individuals with all possible genotypes leads to a 
more accurate mapping when dealing with missing values and give a smoother \qtl\ profile, leading to a more accurate mapping.
\cite{jansen93}.

\begin{figure}[ht]
<<fig=TRUE>>=
augmentedcross <- mqmaugment(mycross, minprob=0.1)
plot.geno(augmentedcross)
@
\caption{$plot.geno$ showing the augmented genotypes of 100 individuals with no
missing values. There are 340 individuals in this plot, because \mqm\ expands
the dataset when filling in missing markers (an average expansion of 3.4 per
individual).}
\end{figure}

\clearpage

\section{QTL modelling and mapping with MQM}

The \emph{hyper} dataset is a backcrossed offspring of mice with two traits in the
dataset: bloodpressure (bp) and sex. Here we show an example of running both
single QTL (scanone) and \mqm\ QTL mapping routinges analysing blood pressure.

% \texttt{qtl.mqm} help page into a \LaTeX{} document

<<>>=
data(hyper)
colors <- c("Black","Green")
lines <- c(2,1)
hyperaug <- mqmaugment(hyper, minprob=1)
result <- mqm(hyperaug)
result_compare <- scanone(hyperaug)
@
And plot the results from both scans (black=mqm, green=scanone), When we look at the output 
from the two methods we see that MQM doesn't have the original markers listed. This is because 
MQM does intervall mapping. Each chromosome is divided into fictional markers spaces stepsize Cm apart. 
A LOD score for underlying QTLs is calculated at these 'fictional' markers. Using the intervall 
mapping approach we obtain smoother profiles than compared to markerbased mapping approaches.

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result, result_compare, col=colors, lwd=lines)
@
\caption{\hyperintrocolors. Both routines
correspond one to one when using no extra parameters}
\end{figure}

For \mqm\ analysis we can follow two approaches (1) build a model by hand, or
(2) use unsupervised backward elimination on a large number of markers.  

First we will start building the model by hand by adding cofactors. On the plot
appears a peek on chromosome 4 at 30 \cM, so let's account for that by
setting a cofactor at the marker nearest to the peek on chromosome 4. This is
achieved by the following steps:

<<>>=
#Summary results shows the highest lodscores per chromosome
summary(result)
#find.marker extracts the marker nearest to chr4 at 30Cm
find.marker(hyperaug,chr=4,pos=30)
#which.marker translates the name into a cofacotr number
toset <- which.marker(hyperaug,"D4Mit164")
cofactorlist <- mqmcofactors(hyperaug,toset)
#scan again
@
\clearpage
\begin{figure}[ht]
<<fig=TRUE>>=
result <- mqm(hyperaug, cofactorlist,plot=T)
@
\caption{\hyperintro.  A cofactor is added at chromosome 4 (D4Mit164) and kept in the
model. The LOD score (evidence) for a second QTL on chromosome 1 increases.
} 
\label{Cofactor4}
\end{figure}

Figure \ref{Cofactor4} shows the effect of setting a single marker as a
cofactor related to the \qtl\ on chromosome 4, followed by an \mqm\ scan.
The marker is never dropped and it passes initial rough thresholding to account
for the, user defined, alpha level. To check this result against a single \qtl\ mapping:

\begin{figure}[ht]
<<fig=TRUE>>=
plot(result, result_compare, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactor at chromosome 4 (D4Mit164) to account for variation explained by that
marker.}
\end{figure}

The second peek on chromosome 1 at 70 \cM\ increases, so try adding that to the
model and check if the model with both cofactors changes the \qtl. Combining
$which.marker$ with $find.marker$, the new cofactornumber $c$ with the cofactor
already in $toset$. When using the function mqmcofactors or mqmsetcofactors, the 
number of cofactors the user is trying to set is compared against the number of 
individuals inside the cross object. If there is any danger of overfitting the 
model the function will error and not return a cofactorlist. Also inside MQM the 
residual degrees of freedom left are checked to make sure also 'usercreated' 
cofactorlists do not overfit the modeling routine.

<<>>=
summary(result)
#we can combine find marker and which.marker commands and expand our toset variable
toset <- c(toset,which.marker(hyperaug,find.marker(hyperaug,1,70)))
cofactorlist <- mqmcofactors(hyperaug,toset)
@
\begin{figure}[ht]
<<fig=TRUE>>=
plot(result, result_compare, col=colors, lwd=lines)
@
\caption{\hyperintrocolors, after introducing a
cofactors at chromosomes 1 and 4 we see just a tiny difference in the likeyhood scores for each chromosome. The LOD scores don't seem to improve much after adding another cofactor on chromosome 4.}
\end{figure}

\clearpage

\mqm\ checks that no markers are included that are less significant than the
alpha level specified. The marker on chromosome 1 is also informative enough to
be included into the model and we can continue this process of adding cofactors
untill there are no more informative markers that can be included.

This could be very time consuming in the case of many QTLs underlying a trait.
\mqm\ also provides unsupervised backward elimination (or elimination) on a large
number of markers by setting cofactors at every other marker. The algorithm
will analyse all the markers and if one is found to be not informative enough
it drops it from the model. This step is repeated until a limited number of
significant cofactors is left.

After backwards elimination it will scan each chromosome using the model that
includes the retained cofactors. Set the plot parameter to TRUE ($plot=T$) to
get a graphical view of the model. Here we set a cofactor at every fifth
marker, and assess which chromosomes may be implicated in high bloodpressure.
Specify the cofactor at every 5 markers by using the $mqmsetcofactors()$ function

<<>>=
cofactorlist <- mqmsetcofactors(hyperaug,5)
@
\begin{figure}[ht]
<<fig=TRUE>>=
result <- mqm(hyperaug, cofactorlist, plot=T)
@
\caption{\hyperintro, after introducing cofactors at every fifth marker and
backward eliminatio to find the most likely model}
\label{Backward1}
\end{figure}
<<>>=
mqmgetmodel(result)
@
The $mqmgetmodel()$ function returns the model from the resulting $scanone$ object.
This is only available when doing automatic backward elimination. The resulting
model can be used to obtain the location and name of the significant markers.

\clearpage
\begin{figure}[ht]
<<fig=TRUE>>=
plot(result, result_compare, col=colors, lwd=lines)
@
\caption{\hyperintrocolors with cofactors at every fifth
marker for mqm, followed by backward elimination
(alpha = 0.02). The resulting profiles are clearly different }
\label{Backward2}
\end{figure}

This mqm run results in a lot of significant markers, with even multiple hits on each chromosome. Figure \ref{Backward2} shows
for an alpha of 0.02 chromosomes 1,2,4,5,6 and (15?) are involved. Lowering the
significance level from 0.02 to 0.002 may yield a smaller model. In biology extensive models 
are sometimes prefered, but in general a simpler model is more easily understood and verified in the wetlab. 
Increasing the significance level (and simplifying the model) also has the advantage that we can 
be more sure of the QTLs we do report.

\begin{figure}[ht]
<<fig=TRUE>>=
result <- mqm(hyperaug, cofactorlist, alfa=0.002, plot=T)
@
\caption{\hyperintro, intially with cofactors at every fifth marker; after backwards elimination (alpha = 0.002).
}
\label{FigLowAlpha}
\end{figure}
\clearpage

When comparing the resulting scan in figure \ref{FigLowAlpha} with the original
$scanone$ result in figure \ref{scanone} there are some striking differences.
Some \qtl\ show higher significance (LOD scores) and some others show lower
significance and are, therefore, estimated to be less likely involved in this
trait.

To replot the plots created during an mqm analysis is also possible. The figures can be reconstructed 
from resulting $scanone$ object using $mqmplotone(result)$ see figure \ref{AutoCofactor}. This 
retrieves the model and the QTLprofile from the result objectattribute $mqmgetmodel(result)$. The functions can only be used with \mqm\
scans, as they have an additinal column $info$ and contain a QTLmodel. The info column contains the estimated
information content per marker. $info$ is calculated from the deviation of the
marker distribution. For example, in a recombinant inbred line we have most
power when both groups (A and B) have 125 mice, and no power when we have 1 A
versus 249 B. Therefore we can multiple the estimated QTL effect by this value
\"to clean\" the QTL profile by giving less weight to less informative markers.

\begin{figure}[ht]
<<fig=TRUE>>=
mqmplotone(result)
@
\caption{\hyperintro, initially with cofactors at every fifth marker; after backward elimination (alpha = 0.002). Figure plotted using $mqmplotone$.
}
\label{AutoCofactor}
\end{figure}

\section{MQM effects}

Figure \ref{FigLowAlpha} implies that chromosomes 1, 2, 4 and 5 are
associated with high bloodpressure. If we want to investigate the
effects of the peek we can use \rqtl\ standard plotting tools to
visualize $main$ and $epistatic$ effects. The following code will plot
those two plots on markers "D1Mit102" (main effect) and the
interaction between "D1Mit102" and "D5Mit213" to show the $main$
effect and the estimated $epistasis$. These markers are initially
chosen because they are considered significant, based on mathematical
distributions used by \mqm\ (we will show a better method, based on
permutations, later). We set cofactors on chromosome 1 because these 
show the highest lod score when using the scan.one function.

To get an estimate of the effects of the QTLs we first investigate the effectplots.

\begin{figure}[ht]
<<fig=TRUE, results=hide>>=
plot.pxg(hyperaug,marker="D1Mit102")
@
\caption{Main effect of marker D1Mit102.}
\label{MainEffectsD1}
\end{figure}
The initial scans for high bloodpressure in figure \ref{Backward}
possibly shows two \qtl\ on chromosome 1. The dual humped shape could be explained by
an interaction between two QTLs on that chromosome. But there are other explainations 
for these kind of curves. We can however find out if there is an interaction on chromosome 
1 by using the effectplot function. To investigate the possible interaction we select markers "D1Mit19" (significant
in figure \ref{Backward1}) and "D1Mit102" (significant in figure \ref{Backward2} and
\ref{AutoCofactor}) and make an effectplot.

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit19", mname2="D1Mit102")
@
\caption{With $effectplot$ discover a possible epistatic effect of
markers D1Mit19 and D1Mit102.}
\label{epistatic1}
\end{figure}

If we, for example, are interested in the interactions between
chromosome 1 and 5, we could make interaction plots between the two
markers with a high LOD score on those chromosomes by using the effect
plot:

\begin{figure}[ht]
<<fig=TRUE>>=
effectplot(hyperaug, mname1="D1Mit102", mname2="D5Mit213")
@
\caption{$effectplot$ for discovering an epistatic effect of markers D1Mit102 and D5Mit213}
\label{epistatic2}
\end{figure}

Figure \ref{epistatic1} shows some evidence for an interaction between the two
markers D1Mit102 and D5Mit213, as both lines are non parallel. Imagine two loci x and y influencing a trait. Parallel lines denote 
no significant interaction between x and y. While non-parallel lines mean the genotype on location y has an effect 
on the effect of the genotype at location x.

\clearpage

\section{Permutation test for significance} 

To estimate significance of the peeks ( and perhaps exclude some markers from our model ) we can use a permutation test. This can be
computationally expensive - repeating the same test thousands of times. If you have access to multiple CPUs on your
computer you can install the SNOW package
\cite{tierney03}\cite{tierney04}, which allows parallel computations on multiple CPU (cores). For small sets, with a limited amount
of traits, the $mqmpermute()$ works well. For large genome wide association studies
(GWAS) use $mqmscanfdr()$ to estimate the FDR across the entire
dataset
at certain \lod\ cutoffs (for this example we use $25$ permutations, for
a real experiment use - typically - $1000$ tests with $b.size=25$ or $50$). b.size is the batchsize per core. If we set 100 permutations using 4 cores and a batchsize of 10, each core gets 10 traits to calculate QTL profiles on. When done another 10 traits are send to the core, untill all 100 traits have been analyzed. In mqmpermutate we do single trait permutations not taking correlation between the traits into account. If we want to estimate false discovery rates, we need to do a whole genome permutation using mqmscanfdr. This method does take correlation between traits into account and gives an unbiased estimate of FDR at different thresholds (userspecified)

\begin{figure}[ht]
<<>>=
require(snow)
results <- mqmpermute(hyperaug,cofactors=cofactorlist,n.clusters=2,n.run=25,b.size=25)
@
<<fig=TRUE>>=
mqmplotpermutation(results)
@
\caption{Calculate significance permuting 25 times over the hyper dataset. 
\qtl\ with a \lod\ higher than
2.5 LOD score can be considered significant (at $alpha=0.05 (green)$ or $alpha=0.10 (blue)$).
This is estimated from permuting a single trait. Chromosomes are signified by the gray gridlines.
}
\end{figure}

For estimating false discovery rates use the function
$mqmscanfdr$. The function scans the traits and counts
observed \qtl\ (markers with a LOD above $x$) when setting a certain
threshold. It permutes all the data leaving the correlation structure
between traits intact. For this small example very high FDR estimates
are calculated because of the small amount of permutations and the
high correlation between traits. We thus discover many QTLs that map 
to the same location, this could normally only happen when we have an 
information sparse marker, or correlated traits as we ussually see in 
microarray experiments.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
mqmscanfdr(multifilled,mqmall,cofactors=cofactorlist,n.clusters=2)
@
\section{MQM and multiple traits}

MQM can analyse multiple traits simultaneously. 
Start by loading a new dataset ($multitrait$). $multitrait$
consists of an arabidopsis RIL cross with 24 metabolites measured (phenotypes).

Start by filling in the genome using the $fill.geno$ function, rather
than $mqmaugment$, which can only handle one trait. To map back the
possible regulatory locations of these traits use plain scanning of
all traits (initially without cofactors). Next plot all the profiles
in a heatmap. In this heatmap the colors represent the LOD score, on
the x-axis the marker number and on the y-axis the traits. The traits
are numbered in the plot. Plot heatmap without cofactors and then the
heatmap with cofactors and backward elimination. The plots show
improvement of the signal to noise ratio.

<<>>=
data(multitrait)
multifilled <- fill.geno(multitrait)
resall <- mqmall(multifilled,n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplotall(resall,"I")
@
\caption{Heatmap of 25 metabolite expression traits in arabidopsis, profiles created using mqm with no cofactors.}
\end{figure}
\clearpage
<<>>=
cofactorlist <- mqmsetcofactors(multifilled,3)
resall <- mqmall(multifilled,cofactors=cofactorlist,n.clusters=2)
@
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplotall(resall,"I")
@
\caption{Heatmap of 25 metabolite expression traits in \At with profiles
created using cofactors at each third marker. Compared to figure 18 the
profile is clearer, because the individual profiles contain less noise.}
\end{figure}
Use $mqmplotnice$ for more graphical output. (This does not show in the
generated PDF, but in R it shows the trait profiles)
\begin{figure}[ht]
<<fig=TRUE>>=
mqmplotnice(resall,legendloc=1)
@
\caption{Results of scanning 25 traits using \mqm\ cofactors at each third marker}
\end{figure}

\clearpage
The next plot is the $mqmcistransplot$.  This plot can be created
for \qtl\ with associated genome locations (like when a, so called
eQTL, correlates with a know microarray probe).  The
two axis are both divided by genetic location. where the X-axis is,
normally, the \qtl\ location and the Y-axis the location of the trait.
To achieve the plot genomic locations need to be associated with the
$scanone$ object.  use $data(locations)$. 

\begin{figure}[ht]
<<fig=TRUE>>=
data(locations)
multiloc <- addloctocross(multifilled,locations)
mqmcistransplot(resall, multiloc, 5, FALSE, TRUE)
@
\caption{mqmcistransplot, available when \qtl\
have associated genome locations. \qtl\ are plotted against the position on the
genome they were measured (here mQTL for \At), cutoff \lod\ 5}
\end{figure}

\clearpage

\section{Overview of all \mqm\ functions}
\begin{table}[ht]
	\caption{Added functionality}
	\centering
	\begin{tabular}{| l | c | }
	\hline
	mqmaugment:& mqm data augmentation \\
	mqm(scan):& mqm modeling and scanning \\
	mqmsetcofactors:& Set cofactors at these markers (or every x marker) \\
	which.marker:& Change markernumbering into mqmformat \\
	mqmall:& mqmall to scan all traits using mqm\\
	bootstrap (AKA permute):& Single trait permutation \\
	mqmscanfdr:& Genome wide False Discovery Rates \\	
	mqmpermObject:& Creates an R/qtl permutationobject from the output of the $permute()$ function \\
	mqmplotall:& plotting of multiple traits (MQMmulti object) \\
	mqmplotnice:& plotting of mutiple traits (MQMmulti object) \\
	mqmplotboot:& plot methode to show single trait permutations \\
	mqmplotone:& plotting of single trait analysis with information content \\
	addloctocross:& Adding genetic locations for traits \\	
	mqmcistransplot:& Genomewide plot of cis- and transQTLs above a threshold \\
	mqmtestnormal:& Tests the normallity of a trait \\ 	
	\hline
	\end{tabular}
	\label{tbl:tabel1}
\end{table}

\clearpage

\section{Final notes}

\subsection{Sex Chromosomes}

The current version of \mqm\ does not treat the sex chromosome as a
special case. You can treat sex as a covariate, of course, but special
recombination rates are not considered. This will change in a future
version.

\subsection{Out of memory}

When using a slack augmentation setting the matrix may grow out of
memory. You will see the following error:\\
\\
ERROR: Dataset too large after augmentation

When this happens please reload your crossobject from file and rerun the mqmaugmentation routine with:\\
1) set $minprob$ parameter higher (closer to 1)\\
2) allow for more augmentations per individual\\
3) allow for more augmentations in total\\
When dealing with a lot of missing markers (This message already shows when $minprob$ is equal to 1), the basic fill.geno
function from R/qtl can be used.

\clearpage

\begin{thebibliography}{9}
	\bibitem{broman09}
		Broman, K.W.; 2009.
		\emph{A brief tour of R/qtl}
		http://www.rqtl.org, R/qtl tutorials.
	\bibitem{broman03}
		Broman, K.W.; Wu, H.; Sen, S.; Churchill, G.A.; 2003.
		\emph{R/qtl: QTL mapping in experimental crosses}
		Bioinformatics, 19:889-890.
	\bibitem{jansen07}
		Jansen R. C.; 2007.
		\emph{Chapter 18 - Quantitative trait loci in inbred lines} 
		Handbook of Stat. Genetics 3th edition,(c) 2007 John Wiley \& Sons, Ltd.
	\bibitem{tierney04}	
		Tierney, L.; Rossini, A.; Li, N.; and Sevcikova, H.; 2004.
		\emph{The snow Package: Simple Network of Workstations} Version 0.2-1. 
	\bibitem{tierney03}
		Rossini, A.; Tierney, L.; and Li, N.; 2003.
		\emph{Simple parallel statistical computing}
		R. UW Biostatistics working paper series University of Washington. 193
	\bibitem{jansen01}	
		Jansen R. C.; Nap J.P.; 2001
		\emph{Genetical genomics: the added value from segregation}
		Trends in Genetics, 17, 388-391.
	\bibitem{jansen94}		
		Jansen R. C.; Stam P.; 1994
		\emph{High resolution of quantitative traits into multiple loci via interval mapping}
		Genetics, 136, 1447-1455. 
	\bibitem{Churchill94}
		Churchill, G. A.; and Doerge, R. W.; 1994
		\emph{Empirical threshold values for quantitative trait mapping}
		Genetics 138, 963–971. 
	\bibitem{jansen93}
		Jansen R. C.; 1993
		\emph{Interval mapping of multiple quantitative trait loci}
		Genetics, 135, 205–211.
	\bibitem{Dempster77}
		Dempster, A. P.; Laird, N. M. and Rubin, D. B.; 1977 
		\emph{Maximum likelihood from incomplete data via the EM algorithm}
		J. Roy. Statist. Soc. B, 39, 1–38.
\end{thebibliography}
\end{document}
